// Initialize histogram region
@0000 00110001 11000000  // lui r1, #c0        // Start address of histogram region (upper 8 bits)
@0002 00001010 10000000  // lli r2, #80        // Number of histogram buckets (128)

// init_histogram:
@0004 00001100 00000000  // lli r4, #00        // Initialize to zero
@0006 00000100 00110010  // sbu r4, (r1)       // Write zero to the current bucket
@0008 00100001 00000001  // addi r1, #01       // Move to the next bucket address
@000a 00100010 11111111  // addi r2, #-1       // Decrement bucket counter
@000c 10001010 11111000  // bnez r2, #-8       // Loop until all buckets are initialized
@000e 00000000 00000000  // nop

// Start histogram collection
@0010 00110000 10000000  // lui r0, #80        // Start address of image data (upper 8 bits)
@0012 00110001 11000000  // lui r1, #c0        // Start address of histogram region (upper 8 bits)
@0014 00001010 10000000  // lli r2, #80        // Outer loop counter (128 rows)
@0016 00001011 10000000  // lli r3, #80        // Inner loop counter (128 columns)

// outer_loop:

// inner_loop:
@0018 00000100 00010011  // lbu r4, (r0)       // Load a pixel value from image data
@001a 00000100 10001001  // sr r4, r4          // Right shift to combine two adjacent pixel values
@001c 00110101 11000000  // lui r5, #c0        // Load histogram base address
@001e 00000101 10000100  // add r5, r4         // Calculate histogram bucket address
@0020 00000110 10110011  // lbu r6, (r5)       // Load current bucket value
@0022 00100110 00000001  // addi r6, #01       // Increment bucket value
@0024 00000110 10110010  // sbu r6, (r5)       // Write updated value back to histogram bucket
@0026 00100000 00000001  // addi r0, #01       // Move to the next pixel address
@0028 00100011 11111111  // addi r3, #-1       // Decrement inner loop counter
@002a 10001011 11101100  // bnez r3, -20      // Loop back if columns remain
@002c 00000000 00000000  // nop

@002e 00100010 11111111  // addi r2, #-1       // Decrement outer loop row counter
@0030 10001010 11100100  // bnez r2, -28      // Loop back if rows remain
@0032 00000000 00000000  // nop                // End of program

// Normalize histogram: Divide by 4 and clip at 128
@0034 00110001 11000000  // lui r1, #c0        // Start address of histogram region (upper 8 bits)
@0036 00001010 10000000  // lli r2, #80        // Number of histogram buckets (128)

// Normalize histogram: Divide by 4 and clip at 128
@0038 00000011 00110011  // lbu r3, (r1)       // Load bucket value
@003a 00000011 01101001  // sr r3, r3          // Divide value by 2 (1st right shift)
@003c 00000011 01101001  // sr r3, r3          // Divide value by 2 (2nd right shift, total 1/4)
@003e 00000100 01100001  // mov r4, r3         // Copy r3 to r4 for comparison
@0040 00100100 10000000  // addi r4, #-80      // Subtract 128 (r4 = r3 - 128)
@0042 10010100 00000100  // bmi r4, #4         // If r4 < 0 (r3 < 128), skip clipping
@0044 00000000 00000000  // nop
@0046 00001011 10000000  // lli r3, #80        // Clip value to 128
@0048 00000011 00110010  // sbu r3, (r1)       // Store clipped value back to histogram
@004a 00100001 00000001  // addi r1, #01       // Move to the next bucket address
@004c 00100010 11111111  // addi r2, #-1       // Decrement bucket counter
@004e 10001010 11101000  // bnez r2, #-18      // Loop until all buckets are normalized
@0050 00000000 00000000  // nop

// Draw histogram
@0052 00110000 11000000  // lui r0, #c0        // Start address of histogram region (upper 8 bits)
@0054 00001001 10000000  // lli r1, #80        // Number of histogram buckets (128)
@0056 00110010 11111111  // lui r2, #ff        // Start address of image memory (upper 8 bits)
@0058 00100010 01111111  // addi r2, #7f       // r2 = bottom of first column (0xFF7F)
@005a 00100010 00000001  // addi r2, #01       // r2 = 0xFF80 (column start address)
@005c 00001011 10000000  // lli r3, #80        // Total rows per column (128)
@005e 00001100 00000001  // lli r4, #01        // White pixel color (1)

// Draw outer loop
//draw_outer_loop:
@0060 00000101 00010011  // lbu r5, (r0)       // Load current bucket height (white count) into r5
@0062 00001110 10000000  // lli r6, #80        // Total rows (128)
@0064 00000110 10100101  // sub r6, r5         // Calculate black count: r6 = total rows - white count

@0066 10000101 00001100  // beqz r5, #c //fill_black_start // If white count is 0, skip to black fill
@0068 00000000 00000000  // nop

// Fill white pixels
//fill_white:
@006a 00000100 01010010  // sbu r4, (r2)       // Write white pixel (1) to current row
@006c 00100010 10000000  // addi r2, #-80      // Move up one row (next pixel)
@006e 00100101 11111111  // addi r5, #-1       // Decrement white pixel counter
@0070 10001101 11111000  // bnez r5, #-8 //fill_white // Continue if more white pixels to fill
@0072 00000000 00000000  // nop

// Fill black pixels
//fill_black_start:
@0074 00001100 00000000  // lli r4, #00        // Black pixel color (0)
//fill_black:
@0076 00000100 01010010  // sbu r4, (r2)       // Write black pixel (0) to current row
@0078 00100010 10000000  // addi r2, #-80      // Move up one row (next pixel)
@007a 00100110 11111111  // addi r6, #-1       // Decrement black pixel counter
@007c 10001110 11111000  // bnez r6, #-8 //fill_black // Continue if more black pixels to fill
@007e 00000000 00000000  // nop

// Move to next column
@0080 00100010 00000001  // addi r2, #01     // Move to the bottom of the next column
@0082 00100000 00000001  // addi r0, #01       // Move to the next bucket address
@0084 00100001 11111111  // addi r1, #-1       // Decrement bucket counter
@0086 10011001 11011000  // bpl r1, #-28//draw_outer_loop // If more buckets remain, continue
@0088 00000000 00000000  // nop
@008a 00000000 00000000  // nop                // End of program
